# PVZ阳光基址分析数据包

## 📦 文件清单

| 文件名 | 大小 | 说明 |
|--------|------|------|
| `libpvz.so` | 28.9MB | PVZ主库文件（ARM64） |
| `x1_object_region.bin` | 64KB | X1中间对象内存区域 (0x30B0000-0x30C0000) |
| `sun_object_region.bin` | 4KB | 阳光对象内存区域 (0x7ACC028000-0x7ACC029000) |
| `memory_maps.txt` | ~50KB | 完整内存映射表 |
| `IDA_ANALYSIS_GUIDE.md` | - | 详细的IDA分析指南 |
| `ida_scan_pointers.py` | - | IDA Python扫描脚本 |

---

## 🎯 快速开始

### 1. 在IDA中加载libpvz.so
```
1. 打开IDA Pro 7.x或更高版本
2. File → Open → 选择 libpvz.so
3. 处理器类型: ARM64 (AArch64)
4. 加载地址: 0x7B67825000 (或选择自动)
```

### 2. 运行扫描脚本
```
1. File → Script file
2. 选择 ida_scan_pointers.py
3. 查看输出，寻找匹配当前阳光值(75)的指针
```

### 3. 手动分析数据段
```
1. 导航到数据段: 0x7B6939B000 (或相对偏移 +0x1B76000)
2. Search → Immediate value → 搜索 0x7ACC028870 (阳光对象地址)
3. 检查找到的地址的交叉引用 (按X键)
```

---

## 🔑 关键信息速查

### 运行时地址（动态，重启会变）
```
libpvz.so基址:     0x7B67825000
数据段:            0x7B6939B000 - 0x7B693CD000
阳光对象:          0x7ACC028870
阳光值:            0x7ACC02887C (+0x0C)
当前值:            75
X1对象:            0x030B0338
```

### 相对偏移（固定，不会变）
```
数据段偏移:        libpvz.so基址 + 0x1B76000
阳光值偏移:        阳光对象基址 + 0x0C
```

---

## 🔍 分析目标

### 主要目标：找到静态指针链
理想的指针链格式：
```
libpvz.so基址 (动态)
  + [固定偏移A]
  = 静态指针地址
  → [读取指针值]
    + [固定偏移B]
    = 另一个指针
    → [读取指针值]
      + 0x0C
      = 阳光值地址
```

### 次要目标：了解对象结构
- GameState类的结构
- 阳光对象的完整布局
- Java对象与C++对象的关系

---

## 📊 已知的内存结构

### 阳光对象结构
```
+0x00: <未知>
+0x04: <未知>
+0x08: <未知>
+0x0C: 阳光值 (int32) = 75 ⭐
+0x10: <未知>
...
```

### X1对象结构（部分）
```
+0x00: 0x00000000706a56c8  (Java对象引用)
+0x08: 0x030b0380030b0368  (可能是两个引用或long值)
+0x10: 0x030b039002b7eec0
+0x18: 0x00000000030b03a8
+0x20: 0x0000007db40ef760
+0x28: 0x030b03c002b88ca0
...
```

---

## ⚙️ IDA脚本使用说明

### ida_scan_pointers.py

**功能：**
1. 扫描数据段中所有指向阳光区域的指针
2. 验证+0x0C偏移处是否为阳光值
3. 搜索单例模式
4. 查找交叉引用

**修改配置：**
如果游戏重启或地址变化，需要修改脚本顶部的配置：
```python
LIB_BASE = 0x新的基址
SUN_OBJECT = 0x新的阳光对象地址
CURRENT_SUN_VALUE = 新的阳光值
```

**输出解读：**
- `⭐⭐⭐ 匹配当前阳光值` - 最有希望的候选指针
- `[XREF]` - 代码中对该地址的引用
- `[Level 1/2]` - 指针链的层级

---

## 🚧 可能遇到的问题

### 问题1：找不到任何指针
**可能原因：**
- 阳光值完全由Java管理，C++层没有直接引用
- 对象是动态分配的，没有静态指针
- 需要分析JNI调用路径

**解决方案：**
- 查看IDA_ANALYSIS_GUIDE.md中的"策略2：分析初始化代码"
- 考虑使用Frida Hook方式

### 问题2：找到的指针游戏重启后失效
**可能原因：**
- 找到的是临时对象的地址，不是静态全局变量
- 需要继续向上追踪引用链

**解决方案：**
- 使用IDA的交叉引用功能（X键）
- 追踪到真正的静态存储位置

### 问题3：IDA脚本报错
**检查事项：**
- IDA版本是否支持Python 3
- 是否在IDA环境中运行（不是普通Python）
- 地址是否有效（可能需要等待IDA完全分析）

---

## 📝 分析记录模板

使用此模板记录你的分析过程：

```
日期: ___________
IDA版本: ___________

扫描结果：
- 找到指针数量: ___
- 匹配阳光值的指针: ___

候选指针1：
  地址: 0x___________
  偏移: 0x___________
  指向: 0x___________
  +0x0C值: ___

验证结果：
  游戏重启前: [ ] 成功 [ ] 失败
  游戏重启后: [ ] 成功 [ ] 失败

注释: 
___________________________________________
```

---

## 🎓 学习资源

如果你是第一次进行逆向分析，建议先了解：

1. **ARM64汇编基础**
   - LDR/STR指令
   - 寄存器使用约定
   - 函数调用约定（AAPCS64）

2. **IDA Pro使用**
   - 基本导航（G键跳转）
   - 交叉引用（X键）
   - 数据类型定义（D键）

3. **Android内存布局**
   - Java heap vs Native heap
   - 内存映射区域
   - SELinux限制

---

## 💡 提示与技巧

### 提示1：利用已知值缩小范围
当前阳光值=75，在IDA中搜索：
- 十进制：75 (可能是其他用途)
- 十六进制：0x4B
- 在可疑地址+0x0C处验证

### 提示2：关注单例模式
单例对象通常：
- 在数据段有静态指针
- 被多个函数引用
- 只初始化一次

### 提示3：查看字符串
搜索相关字符串如：
- "sun", "sunshine"
- "money", "coins"
- "game_state", "player"

---

## 📞 数据采集信息

**采集环境：**
- 设备：Android真机
- PID：32288
- 包名：com.ea.game.pvzfree_cn
- 采集时间：2025-10-20

**游戏状态：**
- 当前阳光：75
- 游戏模式：[未记录]
- 关卡：[未记录]

**工具版本：**
- memtool：arm64-v8a
- libcapstone：v5.x
- 调试服务器：8080端口

---

## 🆘 需要帮助？

如果分析过程中遇到问题，可以参考：

1. **IDA_ANALYSIS_GUIDE.md** - 详细的步骤说明
2. **ida_scan_pointers.py** - 脚本源码中的注释
3. **memory_maps.txt** - 完整的内存布局

祝你分析顺利！🎯

