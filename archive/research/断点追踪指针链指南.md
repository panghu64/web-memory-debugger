# 断点追踪指针链 - 完整指南

## ? 目标
找出阳光地址 `0x6D4662B22C` 的完整指针链

---

## ? 已知信息

```
阳光地址: 0x6D4662B22C
游戏: 植物大战僵尸
PID: (动态获取)
```

---

## ? 方法1: 使用硬件断点（推荐）???

### 步骤1: 运行分析脚本

```powershell
powershell -ExecutionPolicy Bypass -File analyze_pointer_chain.ps1
```

**脚本会自动**:
- ? 读取当前阳光值
- ? 确定地址所在内存区域
- ? 分析libpvz.so段信息
- ? 生成搜索字节序列
- ? 启动实时监控

### 步骤2: 设置硬件写入断点

#### 方法A: 使用IDA Pro + Android调试器

```
1. 附加到游戏进程
   - Debugger > Attach to process
   - 选择: com.ea.game.pvzfree_cn

2. 设置硬件断点
   - 跳转到地址: G键，输入 6D4662B22C
   - 右键 > Add breakpoint > Hardware, write
   - 大小: 4 bytes

3. 继续执行: F9

4. 在游戏中收集阳光

5. 断点触发时:
   - 查看当前指令
   - 查看寄存器（特别是基址寄存器）
   - 查看调用栈
```

#### 方法B: 使用我们的API（如果支持）

```powershell
# 设置硬件断点
$body = @{
    pid = 6913
    address = "6D4662B22C"
    type = "write"
    size = 4
} | ConvertTo-Json

Invoke-RestMethod "http://localhost:8080/api/debug/watchpoint" `
    -Method Post -Body $body -ContentType "application/json"
```

### 步骤3: 分析断点结果

当断点触发时，你会看到类似这样的指令：

```assembly
; 示例1: 直接写入
str w8, [x19, #0x2C]      ; x19是基址，+0x2C是偏移

; 示例2: 通过指针链
ldr x9, [x20, #0x10]      ; x20 + 0x10 = 一级指针
str w8, [x9, #0x2C]       ; x9 + 0x2C = 阳光地址

; 示例3: 更复杂的指针链
ldr x10, [x21]            ; x21 = 基址
ldr x9, [x10, #0x18]      ; x10 + 0x18 = 二级指针
ldr x8, [x9, #0x50]       ; x9 + 0x50 = 三级指针
str w7, [x8, #0x2C]       ; x8 + 0x2C = 阳光地址
```

### 步骤4: 追踪基址

**关键问题**: x19/x20/x21 这些寄存器的值从哪来？

```
1. 查看调用栈，找到调用函数
2. 在调用函数开始处设置断点
3. 单步执行，看基址寄存器如何赋值
4. 重复直到找到静态地址（在libpvz.so数据段中）
```

---

## ? 方法2: 在libpvz.so中搜索指针

### 步骤1: 生成搜索字节

阳光地址 `0x6D4662B22C` 的小端序字节：

```
32位指针: 2C B2 66 D4
64位指针: 2C B2 66 D4 06 00 00 00
```

### 步骤2: 在IDA中搜索

```
1. 打开 libpvz.so
2. Alt+B (Search > Sequence of bytes)
3. 输入: 2C B2 66 D4
4. 搜索范围: .data 段
```

### 步骤3: 分析找到的指针

找到指针后（假设在 `0x6DB77C8100`）:

```
指针地址: 0x6DB77C8100
指针值: 0x6D4662B22C (指向阳光)

基址公式:
[[libpvz.so数据段 + 偏移1] + 偏移2]

其中:
- libpvz.so数据段: 0x6DB77C8000 (动态)
- 偏移1: 0x100
- 偏移2: 0x2C (从断点分析得出)
```

---

## ? 方法3: 内存快照对比

### 原理
在不同游戏状态下抓取内存快照，对比找出指针

### 步骤

```powershell
# 1. 游戏刚启动，阳光=50
$snapshot1 = @{
    pid = 6913
    address = "6DB77C8000"  # libpvz.so数据段
    length = 204800  # 整个数据段
} | ConvertTo-Json
$data1 = Invoke-RestMethod "http://localhost:8080/api/memory/read" `
    -Method Post -Body $snapshot1 -ContentType "application/json"
$data1.data.hex | Out-File snapshot1.txt

# 2. 收集阳光后，阳光=100
Start-Sleep -Seconds 30
$data2 = Invoke-RestMethod "http://localhost:8080/api/memory/read" `
    -Method Post -Body $snapshot1 -ContentType "application/json"
$data2.data.hex | Out-File snapshot2.txt

# 3. 对比两个快照，找变化的4字节
# 变化值应该是: 32 00 00 00 -> 64 00 00 00 (50 -> 100)
```

---

## ? 实战步骤（推荐流程）

### 第一阶段: 确认地址和监控

```powershell
# 1. 运行分析脚本
powershell -ExecutionPolicy Bypass -File analyze_pointer_chain.ps1

# 2. 选择启动实时监控 (Y)

# 3. 在游戏中操作:
#    - 收集阳光
#    - 种植植物
#    - 观察值的变化
```

### 第二阶段: 使用断点定位代码

```
方式A: 使用IDA Pro
1. 附加到进程
2. 设置硬件写入断点: 0x6D4662B22C
3. 收集阳光，触发断点
4. 记录指令和寄存器

方式B: 使用我们的API
1. 调用 /api/debug/watchpoint
2. 查看返回的寄存器信息
```

### 第三阶段: 追踪指针链

根据断点信息构建指针链：

```
假设断点显示:
地址: 0x6DB6C84A20
指令: str w8, [x19, #0x2C]
x19 = 0x6D4662AFF4

那么:
阳光地址 = x19 + 0x2C
        = 0x6D4662AFF4 + 0x2C
        = 0x6D4662B020  (应该等于我们的目标地址)

现在需要找 x19 的来源...
```

### 第四阶段: 验证指针链

```powershell
# 假设找到了指针链: [[libpvz.so + 0x100] + 0x2C]

# 1. 获取libpvz.so数据段基址
$maps = Invoke-RestMethod "http://localhost:8080/api/memory/maps?pid=6913"
$libpvz = $maps.data | Where-Object { $_.path -like "*libpvz.so" -and $_.perms -eq "rw-p" }
$baseAddr = $libpvz.start
Write-Host "基址: 0x$baseAddr"

# 2. 读取一级指针
$pointer1Addr = ([Convert]::ToInt64($baseAddr, 16) + 0x100).ToString("x")
$body = @{pid=6913;address=$pointer1Addr;length=8} | ConvertTo-Json
$r1 = Invoke-RestMethod "http://localhost:8080/api/memory/read" -Method Post -Body $body -ContentType "application/json"
# 解析64位指针...

# 3. 加上偏移得到最终地址
# 应该等于 0x6D4662B22C
```

---

## ? 常见指针链模式

### 模式1: 一级静态指针（最简单）?

```
[libpvz.so + 偏移]

示例:
阳光地址 = [0x6DB77C8100]
```

### 模式2: 二级指针

```
[[libpvz.so + 偏移1] + 偏移2]

示例:
一级指针 = libpvz.so + 0x100 = 0x6DB77C8100
阳光地址 = [0x6DB77C8100] + 0x2C
```

### 模式3: 多级指针链

```
[[[libpvz.so + 偏移1] + 偏移2] + 偏移3]

示例:
基址 = libpvz.so + 0x100
一级指针地址 = [基址] + 0x18
二级指针地址 = [一级指针地址] + 0x50
阳光地址 = [二级指针地址] + 0x2C
```

---

## ?? 工具命令速查

### 读取内存
```powershell
$body = @{pid=6913;address="6D4662B22C";length=4} | ConvertTo-Json
$r = Invoke-RestMethod "http://localhost:8080/api/memory/read" -Method Post -Body $body -ContentType "application/json"
$r.data.hex
```

### 写入内存（测试）
```powershell
$body = @{pid=6913;address="6D4662B22C";value=9990} | ConvertTo-Json
Invoke-RestMethod "http://localhost:8080/api/memory/write" -Method Post -Body $body -ContentType "application/json"
```

### 获取内存映射
```powershell
$maps = Invoke-RestMethod "http://localhost:8080/api/memory/maps?pid=6913"
$maps.data | Where-Object { $_.path -like "*libpvz.so" } | Format-Table
```

### 反汇编代码
```powershell
$body = @{pid=6913;address="6DB6C84A20";count=20} | ConvertTo-Json
$d = Invoke-RestMethod "http://localhost:8080/api/disasm" -Method Post -Body $body -ContentType "application/json"
$d.data | ForEach-Object { "$($_.address): $($_.mnemonic) $($_.opStr)" }
```

---

## ? 预期结果

### 最终输出示例

```
指针链: [[libpvz.so + 0x1D8] + 0x768] + 0x5560

验证:
1. libpvz.so数据段基址: 0x6DB77C8000 (动态，每次启动不同)
2. 一级指针地址: 0x6DB77C8000 + 0x1D8 = 0x6DB77C81D8
3. 读取一级指针值: [0x6DB77C81D8] = 0x6D4662A000
4. 二级指针地址: 0x6D4662A000 + 0x768 = 0x6D4662A768
5. 读取二级指针值: [0x6D4662A768] = 0x6D4662AAC0
6. 阳光地址: 0x6D4662AAC0 + 0x5560 = 0x6D4662B22C ?

重启验证:
- 游戏重启后，只需重新获取libpvz.so基址
- 其他偏移(0x1D8, 0x768, 0x5560)保持不变
- 即可定位到新的阳光地址
```

---

## ? 调试技巧

### 技巧1: 确认地址有效性
```powershell
# 修改阳光值测试
$body = @{pid=6913;address="6D4662B22C";value=9999} | ConvertTo-Json
Invoke-RestMethod "http://localhost:8080/api/memory/write" -Method Post -Body $body -ContentType "application/json"

# 立即读取验证
$body2 = @{pid=6913;address="6D4662B22C";length=4} | ConvertTo-Json
$r = Invoke-RestMethod "http://localhost:8080/api/memory/read" -Method Post -Body $body2 -ContentType "application/json"
# 应该显示 9999
```

### 技巧2: 使用日志追踪
在游戏操作时记录时间戳和阳光值变化，帮助分析断点触发时机

### 技巧3: 对比不同关卡
不同关卡的阳光对象可能在不同位置，通过对比找出共同的指针路径

---

## ? 预期完成

**完成后您将得到**:
- ? 完整的指针链公式
- ? 可在游戏重启后使用的稳定指针
- ? 详细的分析报告
- ? 可复用的方法论

**下一步**:
- 用相同方法找其他值（金币、植物冷却等）
- 创建自动化修改脚本
- 构建完整的修改器

---

**准备好了吗？运行脚本开始分析！**

```powershell
powershell -ExecutionPolicy Bypass -File analyze_pointer_chain.ps1
```

祝您成功找到指针链！?

