# Cheat Engine配合分析指针链 - 详细指南

## ? 目标
找出阳光地址 `0x6D4662B22C` 的访问代码和可能的指针

---

## ? 已知信息（来自IDA分析）

### 关键发现
```
阳光地址: 0x6D4662B22C
内存类型: Java堆内存 (dalvik-main space)
结论: ? 不存在C++静态指针链
原因: 阳光由Java对象管理，不在libpvz.so中
```

### 这意味着
- ? 可以通过CE直接修改（地址有效）
- ? 不能通过libpvz.so找静态指针
- ?? 地址每次启动都变（Java GC动态分配）
- ? 可以通过访问代码找到对象引用

---

## ? 方法1: Cheat Engine "Find what writes"（推荐）???

### 步骤1: 连接到游戏
```
1. 打开Cheat Engine
2. 点击电脑图标
3. 选择进程: com.ea.game.pvzfree_cn (PID: 6913)
4. 点击"打开"
```

### 步骤2: 添加地址
```
1. 手动添加地址: Ctrl+M > Add Address Manually
2. 地址: 6D4662B22C
3. 类型: 4 Bytes (Integer)
4. 描述: 阳光值
5. 点击OK
```

### 步骤3: 查找写入代码
```
1. 右键刚添加的地址
2. 选择: Find out what writes to this address
3. 弹出"Debugger Options"窗口
4. 点击"Yes"允许调试
```

### 步骤4: 触发写入
```
在游戏中执行以下任一操作:
- 收集掉落的阳光
- 种植一个植物（消耗阳光）
- 向日葵生产阳光
- 进入下一波僵尸（可能触发阳光变化）
```

### 步骤5: 分析结果
CE会显示类似这样的记录:
```
Address             Instruction
----------------------------------------------
boot-framework.oat  str w8, [x19, #0x2C]

或者:
libpvz.so+XXXXXX    mov dword ptr [rsi+2C], eax
```

### 步骤6: 记录关键信息
```
记录以下信息:
1. 写入指令: str w8, [x19, #0x2C]
2. 基址寄存器: x19
3. 偏移量: 0x2C
4. x19的值: 0x6D4662B000 (示例)
5. 代码位置: libpvz.so+XXXXXX 或 oat文件
```

---

## ? 方法2: Cheat Engine "Find what accesses"（读取追踪）

### 更温和的方法
```
1. 右键地址
2. 选择: Find out what accesses this address
3. 在游戏中正常游戏（阳光显示会触发读取）
4. 观察哪些代码在读取阳光值
```

### 可能的读取位置
- UI渲染代码（显示阳光数字）
- 植物种植检查（是否有足够阳光）
- 存档保存代码

---

## ? 方法3: 手动追踪基址

### 假设CE显示的写入指令是:
```assembly
str w8, [x19, #0x2C]
```

### 分析步骤

#### 第1步: 确定x19是什么
```
x19寄存器的值: 0x6D4662B200 (示例)
阳光地址: 0x6D4662B22C
关系: x19 + 0x2C = 阳光地址
```

说明: x19指向一个对象，偏移+0x2C是阳光字段

#### 第2步: 在x19地址设置访问断点
```
1. 添加地址: 0x6D4662B200
2. 类型: 8 Bytes (64位指针)
3. Find what writes to this address
4. 查看谁在设置这个对象指针
```

#### 第3步: 追溯到静态位置
```
重复步骤1-2，直到找到:
- 在libpvz.so数据段中的指针
- 或者一个全局单例对象

最终可能得到:
[[libpvz.so + 偏移1] + 偏移2] + 0x2C = 阳光地址
```

---

## ?? 重要提示：Java对象的特殊性

### 为什么难找指针链？

根据IDA分析文档，阳光对象的特点：

```
1. 动态分配: Java GC管理，地址不固定
2. 无C++引用: libpvz.so不持有指针
3. 访问方式: 通过JNI调用Java方法
4. 生命周期: 与关卡对象绑定
```

### 可能的访问模式

```
方式A: C++临时访问（最常见）
  Java对象地址 → JNI传递给C++ → 临时使用 → 不保存

方式B: 通过全局引用
  JavaVM → FindClass → GetFieldID → GetIntField
  (这种方式每次都是动态查找，无静态指针)

方式C: 局部引用表
  JNI LocalRef表 → Java对象
  (仅在JNI调用期间有效)
```

---

## ? 实际可行的方案

### 方案A: CE直接搜索法（最简单）???

#### 每局游戏重新搜索
```
1. 进入关卡，记录初始阳光（如50）
2. CE搜索: 50 (4 Bytes)
3. 种植物消耗阳光（剩25）
4. CE再次搜索: 25
5. 重复2-3次，找到唯一地址
6. 修改为9990，冻结
```

**优点**: 
- 简单可靠
- 5分钟内完成
- 不需要找指针链

**缺点**:
- 每局重新搜索
- 需要手动操作

---

### 方案B: 记录对象基址模式

#### 第1步: 找到对象基址
```
假设CE显示写入指令:
str w8, [x19, #0x2C]
x19 = 0x6D4662B200

那么:
对象基址 = 0x6D4662B200
阳光偏移 = +0x2C
```

#### 第2步: 寻找这个对象
```
在CE中搜索指针:
1. 类型: 8 Bytes (指针)
2. 值: 6D4662B200
3. 在libpvz.so数据段中搜索
```

如果找到，假设在 `0x6DB77C8100`:
```
指针链: [[0x6DB77C8100] + 0x2C]
```

#### 第3步: 验证稳定性
```
1. 记录指针地址: 0x6DB77C8100
2. 重启游戏
3. 检查这个地址是否仍指向新的对象
4. 如果不是，说明这也是动态分配的

继续追踪直到找到libpvz.so中的静态地址
```

---

## ? 快速操作指南

### 现在开始（配合我的提示）

```powershell
# 我会给您执行的命令，您执行CE操作
```

#### 第1步: 确认地址有效性
**您的操作（在CE中）**:
```
1. 附加到游戏进程
2. 添加地址: 6D4662B22C
3. 类型: 4 Bytes
4. 查看当前值
```

**请告诉我**: 当前阳光值是多少？

#### 第2步: 测试修改
**您的操作（在CE中）**:
```
1. 修改阳光为 9999
2. 观察游戏中的阳光显示
```

**请告诉我**: 游戏中的阳光显示是否变为9999？

#### 第3步: 查找写入
**您的操作（在CE中）**:
```
1. 右键地址 > Find out what writes to this address  
2. 在游戏中收集一个阳光
3. 观察CE的调试窗口
```

**请告诉我**: 
- 捕获到几条记录？
- 显示的指令是什么？
- 寄存器值是什么？

---

## ? 根据CE结果的后续分析

### 情况A: 如果捕获到写入代码

**示例结果**:
```
Address: boot-framework.oat+XXXXXX
Instruction: str w8, [x19, #0x2C]
x19 = 6D4662B200
w8 = 100 (新阳光值)
```

**下一步**:
1. 记录对象基址: 0x6D4662B200
2. 在CE中搜索这个值（8字节指针）
3. 查找谁持有这个对象的引用

### 情况B: 如果是Java代码访问

**显示结果**:
```
Address: boot.oat+XXXXXX
或: libart.so+XXXXXX
```

**结论**: 
- 这是纯Java访问
- 无法通过内存找静态指针链
- 需要反编译APK查看Java代码

---

## ? 最终建议

### 如果您的目标是"修改阳光"

? **直接用CE搜索修改即可**
- 每局5分钟搜索
- 修改+冻结
- 无限阳光达成

### 如果您的目标是"学习指针链"

?? **Java对象没有传统意义的指针链**
- Java对象由GC管理
- 引用关系是类.字段，不是内存指针
- 需要反编译APK查看类结构

### 如果想深入研究

? **建议路线**:
1. 反编译APK（用jadx）
2. 查找Sun相关的Java类
3. 分析类的字段和方法
4. 理解对象创建和管理流程

---

## ? 立即开始

### 配合我一步步来：

**第1步**: 请在CE中操作
```
1. 附加到游戏（PID: 6913）
2. 添加地址: 6D4662B22C
3. 查看当前值
```

**请告诉我结果**，然后我会指导下一步！

---

**关键点**: 由于这是Java对象，我们主要是验证地址有效性，并通过CE的"Find what accesses"找到访问代码，而不是传统的静态指针链。

准备好了吗？请执行第1步并告诉我结果！?

