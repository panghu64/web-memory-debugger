# 后端命令速查 - 阳光指针分析

## ? 目标
使用后端memtool命令分析阳光地址 `0x6D4662B22C`

---

## ? 准备工作

### 游戏信息
```powershell
# 获取游戏PID
adb shell "ps -A | grep pvz"
# 输出: u0_a374   6913  ...
# PID = 6913
```

### 配置变量（PowerShell）
```powershell
$GamePid = 6913
$SunAddr = "6D4662B22C"
$AppPath = "/data/data/com.example.myapplication"
$MemtoolPath = "$AppPath/files/memtool_procmem"
```

---

## ? 常用命令

### 1. 读取阳光值
```powershell
# 单次读取
adb shell "su -c 'cd $AppPath/lib && LD_LIBRARY_PATH=. $MemtoolPath read $GamePid $SunAddr 4'"

# 示例输出: 32 00 00 00  (十六进制，小端序)
# 转换: 0x00000032 = 50 (阳光值)
```

### 2. 修改阳光值
```powershell
# 修改为9999 (0x270F)
# 小端序: 0F 27 00 00
adb shell "su -c 'cd $AppPath/lib && LD_LIBRARY_PATH=. $MemtoolPath write $GamePid $SunAddr 0F270000 4'"

# 或直接使用十进制（如果memtool支持）
adb shell "su -c 'cd $AppPath/lib && LD_LIBRARY_PATH=. $MemtoolPath write $GamePid $SunAddr 9999 4'"
```

### 3. 实时监控阳光（循环）
```powershell
# PowerShell循环监控
while ($true) {
    $output = adb shell "su -c 'cd $AppPath/lib && LD_LIBRARY_PATH=. $MemtoolPath read $GamePid $SunAddr 4'"
    $time = Get-Date -Format 'HH:mm:ss'
    Write-Host "[$time] 阳光: $output"
    Start-Sleep -Seconds 1
}
# 按Ctrl+C停止
```

### 4. 获取libpvz.so段信息
```powershell
# 获取所有段
adb shell "su -c 'cat /proc/$GamePid/maps | grep libpvz.so'"

# 只看数据段（rw-p）
adb shell "su -c 'cat /proc/$GamePid/maps | grep libpvz.so | grep rw-p'"

# 示例输出:
# 6db77c8000-6db77fa000 rw-p ... libpvz.so
# 数据段基址: 0x6db77c8000
```

### 5. 读取数据段查找指针
```powershell
# 读取数据段开头
$DataSegStart = "6db77c8000"
adb shell "su -c 'cd $AppPath/lib && LD_LIBRARY_PATH=. $MemtoolPath read $GamePid $DataSegStart 256'"

# 在输出中查找: 2C B2 66 D4 (阳光地址的字节)
```

### 6. 反汇编代码段
```powershell
# 通过API反汇编
$body = @{pid=6913;address="6db5c53000";count=30} | ConvertTo-Json
Invoke-RestMethod "http://localhost:8080/api/disasm" -Method Post -Body $body -ContentType "application/json"
```

---

## ? 分步配合流程

### 第1步: 验证地址有效性

**我的命令**:
```powershell
adb shell "su -c 'cd /data/data/com.example.myapplication/lib && LD_LIBRARY_PATH=. /data/data/com.example.myapplication/files/memtool_procmem read 6913 6D4662B22C 4'"
```

**请执行并告诉我**:
- 输出是什么？
- 能否读取到数据？

---

### 第2步: 测试修改

**我的命令**:
```powershell
# 修改为8888 (0x22B8)
# 小端序: B8 22 00 00
adb shell "su -c 'cd /data/data/com.example.myapplication/lib && LD_LIBRARY_PATH=. /data/data/com.example.myapplication/files/memtool_procmem write 6913 6D4662B22C B8220000 4'"
```

**请执行并告诉我**:
- 游戏中阳光是否变成8888？
- 如果成功，说明地址有效！

---

### 第3步: 实时监控（配合操作）

**我的命令**:
```powershell
# 启动监控循环
$prevSun = -1
while ($true) {
    $output = adb shell "su -c 'cd /data/data/com.example.myapplication/lib && LD_LIBRARY_PATH=. /data/data/com.example.myapplication/files/memtool_procmem read 6913 6D4662B22C 4'" | Out-String
    
    if ($output -match "([0-9a-fA-F]{2}\s+){3,}") {
        $hex = ($output -replace '\s+', '') -replace '[^0-9a-fA-F]', ''
        if ($hex.Length -ge 8) {
            $b = @($hex.Substring(0,2), $hex.Substring(2,2), $hex.Substring(4,2), $hex.Substring(6,2))
            $sun = [Convert]::ToInt32("$($b[3])$($b[2])$($b[1])$($b[0])", 16)
            
            if ($sun -ne $prevSun -and $prevSun -ne -1) {
                $change = $sun - $prevSun
                Write-Host "[变化] $prevSun -> $sun ($(if($change -gt 0){"+"})$change)" -ForegroundColor Yellow
            }
            $prevSun = $sun
        }
    }
    
    Start-Sleep -Milliseconds 500
}
```

**您的操作**:
- 在游戏中收集阳光
- 在游戏中种植植物
- 观察我的输出

---

### 第4步: 搜索指针

**搜索字节序列**:
```
目标地址: 0x6D4662B22C
小端序64位: 2C B2 66 D4 06 00 00 00
小端序32位: 2C B2 66 D4
```

**在libpvz.so数据段搜索**:
```powershell
# 数据段基址（从maps获取）
$DataSeg = "6db77c8000"

# 读取数据段前4KB
adb shell "su -c 'cd /data/data/com.example.myapplication/lib && LD_LIBRARY_PATH=. /data/data/com.example.myapplication/files/memtool_procmem read 6913 $DataSeg 4096'"

# 手动查找输出中是否包含: 2C B2 66 D4
```

**如果找到指针**:
```
假设在偏移+0x100处找到
指针地址 = 0x6db77c8100
读取这个地址验证:
```

```powershell
adb shell "su -c 'cd /data/data/com.example.myapplication/lib && LD_LIBRARY_PATH=. /data/data/com.example.myapplication/files/memtool_procmem read 6913 6db77c8100 8'"
# 应该输出: 2C B2 66 D4 06 00 00 00
```

---

## ? 关键：Java对象的现实

### 根据IDA文档的结论

```
阳光存储: Java堆对象字段
访问方式: Java代码 → JNI → boot-framework.oat
C++层作用: 仅负责渲染，临时通过JNI获取值
指针链: ? 不存在传统的C++静态指针链
```

### 实际情况

**Java对象结构**（推测）:
```java
class GameBoard {
    int mSunCount;  // 偏移可能是 +0x2C
    ...
}
```

**访问模式**:
```
Java: board.mSunCount = 100
   ↓ 编译为
ART: ldr x19, [某个地方]  // 获取board对象地址
     str w8, [x19, #0x2C]  // 写入mSunCount字段
```

**基址来源**:
- x19可能从栈、寄存器、或Java引用表获取
- **每次调用都是动态的**
- 不存在固定的内存指针链

---

## ? 我们能做什么

### ? 可以做的
1. **直接修改**: CE搜索并修改，每局重新搜索
2. **监控变化**: 实时观察阳光值变化
3. **理解机制**: 学习Java对象内存模型

### ? 做不到的
1. **静态指针链**: Java对象没有C++式的静态指针
2. **重启后定位**: GC会移动对象，地址变化
3. **通过libpvz.so**: C++层不持有Java对象指针

---

## ? 推荐方案

### 方案1: 每局快速搜索（最实用）
```
时间: 2分钟
工具: Cheat Engine或GameGuardian
步骤: 搜索->过滤->修改->冻结
效果: 无限阳光
```

### 方案2: 通过我的后端监控（学习用）
```
时间: 实时
工具: 我们的Web调试器 + memtool
步骤: 运行监控脚本，观察变化
效果: 理解内存访问模式
```

### 方案3: 反编译APK（深入研究）
```
时间: 1小时
工具: jadx
步骤: 反编译->查找类->分析代码
效果: 完全理解阳光系统
```

---

## ? 立即开始

### 简单测试（1条命令）

```powershell
# 读取当前阳光
adb shell "su -c 'cd /data/data/com.example.myapplication/lib && LD_LIBRARY_PATH=. /data/data/com.example.myapplication/files/memtool_procmem read 6913 6D4662B22C 4'"
```

**请执行这个命令并告诉我输出！**

如果成功读取，我会继续指导下一步。如果失败，我会帮您排查问题。

准备好了吗？?

